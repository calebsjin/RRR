library(mvtnorm)
library(ggplot2)
library(reshape)
rm(list=ls())
## Data & Model##
row1 <- c(1,0,0,2,-1,0,0,0,0,0,1,-1)
row2 <- c(0,1,0,0,0,-3,2,0,0,0,-1,3)
row3 <- c(0,0,1,0,0,0,0,3,-3,4,2,2)
C <- rbind(row1,row2,row3,row1,row2,row2,row3)
true.rank <- 3
p <- dim(C)[1]
q <- dim(C)[2]
true.sig2 <- 2
true.SIGe <- diag(true.sig2,q)
n=100
a=b=1
tau2=1e-3
MC.size=5000
burn_in=3000
## Reduced Rank Regression model ##
reptn <- 500
TPR <- rep(NA,reptn)
log.ML <- matrix(NA,reptn,p)
hat.rank <- rep(NA,reptn)
for (i in 1:reptn) {
  t1=Sys.time()
  
  set.seed(2144+i)
  X <- matrix(rnorm(n*p,0,1),n,p)
  E <- rmvnorm(n, rep(0,q), true.SIGe, method="chol") 
  Y=X%*%C+E
  for (r in 1:p) {
    Hat.A <- array(NA,dim = c(p,r,MC.size))
    Hat.B <- array(NA,dim = c(q,r,MC.size))
    Hat.C <- array(NA,dim = c(p,q,MC.size))
    Hat.sig2 <- rep(NA,MC.size)
    # initial values
    hat.C <- coef(lm(Y~X-1))
    if (r==1){
      hat.B <- as.matrix(hat.C[1:r,])
    } else {
      hat.B <- t(hat.C[1:r,])
    }
    if (r==p) {
      hat.A <- diag(1,r)
    } else {
      hat.A <- rbind(diag(1,r),hat.C[(r+1):p,]%*%hat.B%*%solve(crossprod(hat.B)))
    }
    hat.sig2 <- mean(diag(tcrossprod(Y-X%*%hat.A%*%t(hat.B))))  #true.sig2
    ## ICM ##
    for (jin in 1:MC.size) {
      # mode of A
      if (r==p){
        Hat.A[,,jin] <- hat.A
      } else {
        for(j in (r+1):p) {
          Sig.A_j <- solve(crossprod(hat.B)*as.numeric(crossprod(X[,j]))/hat.sig2+diag(tau2,r))
          hat.a_j <- Sig.A_j%*%t(hat.B)%*%t(Y-X[,-j]%*%hat.A[-j,]%*%t(hat.B))%*%X[,j]/hat.sig2
          hat.A[j,] <- hat.a_j
        }
        Hat.A[,,jin] <- hat.A
      }
      # mode of B
      Sig.B_l <- solve(crossprod(X%*%hat.A)/hat.sig2+diag(tau2,r))
      hat.B <- t(Sig.B_l%*%t(X%*%hat.A)%*%Y/hat.sig2)
      Hat.B[,,jin] <- hat.B
      hat.C <- hat.A%*%t(hat.B)
      Hat.C[,,jin] <- hat.C
      # mode of sig2
      hat.sig2 <- 0.5*(b+sum(diag(tcrossprod(Y-X%*%hat.C))))/((q*n+a)/2+1)
      Hat.sig2[jin] <- hat.sig2
    }
    hat.C <- apply(Hat.C[,,-(1:burn_in)],c(1,2),mean)
    hat.sig2 <- mean(Hat.sig2[-(1:burn_in)])
    log.y.theta <- -1/2*n*q*log(2*pi*hat.sig2)-1/(2*hat.sig2)*sum(diag(crossprod(Y-X%*%hat.C)))
    log.ML[i,r] <- log.y.theta - r*(p+q-r)/2*log(n*q)
  }
  hat.rank[i] <- which.max(log.ML[i,])
  TPR[i] <- hat.rank[i]==true.rank
  print(c(i,hat.rank[i]))
  print(Sys.time()-t1)
}
hat.rank;mean(hat.rank)
TPR;mean(TPR)

log.ML.data <- data.frame(log.ML[1:10,])
colnames(log.ML.data)<-c(1:7)
log.ML.data <- t(log.ML.data)
#colnames(log.ML.data) <- 1:reptn
log.ML.data <- melt(log.ML.data,id='id' )
names(log.ML.data)[1:2] <- c('rank','id')
log.ML.data$id <- as.factor(log.ML.data$id)
plot.lap <- ggplot(log.ML.data,aes(x=rank,y = value))+
  geom_line(aes(colour=id,linetype=id),size=1)+
  geom_point(color='red',size=0.2)+ylab(expression(logp(y))) + 
  scale_x_continuous(1:7,breaks=1:7)

setwd('C:/Bayes/Statistics/950 Bayesian Model Selection(18 Spring)/Course Project')
ggsave(filename = 'plot.lap.pdf',plot=plot.lap )
save(list = ls(), file = 'Laplace.RData')
       