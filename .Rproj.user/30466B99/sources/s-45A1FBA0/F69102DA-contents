library(mvtnorm)
library(invgamma)
library(xtable)
rm(list=ls())
## Data & Model##
row1 <- c(1,0,0,2,-1,0,0,0,0,0,1,-1)
row2 <- c(0,1,0,0,0,-3,2,0,0,0,-1,3)
row3 <- c(0,0,1,0,0,0,0,3,-3,4,2,2)
C <- rbind(row1,row2,row3,row1,row2,row2,row3)
true.rank <- 3
p <- dim(C)[1]
q <- dim(C)[2]
true.sig2 <- 2
true.SIGe <- diag(true.sig2,q)
n=100
a=b=1
tau2=1e-3
MC.size=5000
burn_in=3000
reptn <- 125
MC3.m.like <- array(NA,dim = c(reptn,p))
DIC <- array(NA,dim = c(reptn,p))
TPR.GD <- rep(NA,reptn)
hat.rank <- rep(NA,reptn)
for (i in 1:reptn) {
  t1=Sys.time()
  v=0
  set.seed(2144+i+125*v)
  X <- matrix(rnorm(n*p,0,1),n,p)
  E <- rmvnorm(n, rep(0,q), true.SIGe, method="chol") 
  Y=X%*%C+E
  hat.C.r <- array(NA,dim = c(p,q,p))
  ## Reduced Rank Regression model ##
  for (r in 1:p) {
    Hat.A <- array(NA,dim = c(p,r,MC.size))
    Hat.B <- array(NA,dim = c(q,r,MC.size))
    Hat.C <- array(NA,dim = c(p,q,MC.size))
    Hat.sig2 <- rep(NA,MC.size)
    # initial values
    hat.C <- coef(lm(Y~X-1))
    if (r==1){
      hat.B <- as.matrix(hat.C[1:r,])
    } else {
      hat.B <- t(hat.C[1:r,])
    }
    if (r==p) {
      hat.A <- diag(1,r)
    } else {
      hat.A <- rbind(diag(1,r),hat.C[(r+1):p,]%*%hat.B%*%solve(crossprod(hat.B)))
    }
    hat.sig2 <- mean(diag(tcrossprod(Y-X%*%hat.A%*%t(hat.B))))  #true.sig2
    MC.theta <- array(NA,dim = c(r*(p+q-r)+1,MC.size))
    ## MCMC ##
    for (jin in 1:MC.size) {
      # Sampling A
      if (r==p){
        Hat.A[,,jin] <- hat.A
      } else {
        for(j in (r+1):p) {
          Sig.A_j <- solve(crossprod(hat.B)*as.numeric(crossprod(X[,j]))/hat.sig2+diag(tau2,r))
          mu.A_j <- Sig.A_j%*%t(hat.B)%*%t(Y-X[,-j]%*%hat.A[-j,]%*%t(hat.B))%*%X[,j]/hat.sig2
          hat.a_j <- rmvnorm(n=1,mean = mu.A_j,sigma = Sig.A_j)
          hat.A[j,] <- hat.a_j
        }
        Hat.A[,,jin] <- hat.A
      }
      # Sampling B
      Sig.B_l <- solve(crossprod(X%*%hat.A)/hat.sig2+diag(tau2,r))
      for(l in 1:q) {
        mu.B_l <- Sig.B_l%*%t(X%*%hat.A)%*%Y[,l]/hat.sig2
        hat.b_l <- t(rmvnorm(n=1,mean = mu.B_l,sigma = Sig.B_l))
        hat.B[l,] <- t(hat.b_l)
      }
      Hat.B[,,jin] <- hat.B
      Hat.C[,,jin] <- hat.A%*%t(hat.B)
      #Sampling Sig2
      hat.sig2 <- rinvgamma(n = 1,shape = (q*n+a)/2,rate = 0.5*(b+sum(diag(tcrossprod(Y-X%*%hat.A%*%t(hat.B))))))
      Hat.sig2[jin] <- hat.sig2
      MC.theta[,jin] <- c(Hat.A[-(1:r),,jin],Hat.B[,,jin],hat.sig2)
    }
    hat.C <- apply(Hat.C[,,-(1:burn_in)],c(1,2),mean)
    hat.C.r[,,r] <- hat.C
    hat.sig2 <- mean(Hat.sig2[-(1:burn_in)])
    MC.mean <- apply(MC.theta[,-(1:burn_in)],1,mean)
    MC.var <- cov(t(MC.theta[,-(1:burn_in)]))
    ## GD ##
    MC.log.f <- rep(NA,MC.size-burn_in)
    MC.log.g <- rep(NA,MC.size-burn_in)
    j=0
    for (jin in (burn_in+1):MC.size) {
      j=j+1
      logP.A.B.sig2 <- -0.5*r*(p+q-r)*log(2*pi/tau2)-0.5*tau2*sum(MC.theta[1:(r*(p+q-r)),jin]^2)+a/2*log(b/2)-
        log(gamma(a/2))-(a/2+1)*log(MC.theta[-(1:(r*(p+q-r))),jin])-b/(2*MC.theta[-(1:(r*(p+q-r))),jin])
      MC.log.f[j] <- -0.5*(n*q*log(2*pi*Hat.sig2[jin])+1/Hat.sig2[jin]*sum(diag(crossprod(Y-X%*%Hat.C[,,jin]))))+logP.A.B.sig2
      MC.log.g[j] <- dmvnorm(MC.theta[,jin],MC.mean,MC.var,log = TRUE)
    }
    MC.log.g_f <- MC.log.g-MC.log.f
    MC3.m.like[i,r] <- log(length(MC.log.f))-(MC.log.g_f[1]+log(sum(exp(MC.log.g_f-MC.log.g_f[1]))))
  }
  hat.rank[i] <- which.max(MC3.m.like[i,])
  TPR.GD[i] <- hat.rank[i]==true.rank
  print(c(i,hat.rank[i]))
  print(Sys.time()-t1)
}
hat.rank
data.frame(mean.rank=mean(hat.rank),TPR.GD=mean(TPR.GD))
save(list = ls(), file = paste0('GD-',v,'.RData'))